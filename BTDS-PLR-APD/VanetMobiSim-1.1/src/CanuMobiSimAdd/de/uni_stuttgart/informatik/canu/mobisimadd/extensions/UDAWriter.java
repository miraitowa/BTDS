package de.uni_stuttgart.informatik.canu.mobisimadd.extensions;

/**
 * <p>Title: AWML Reader</p>
 * <p>Description: </p>
 * <p>Copyright: Copyright (c) 2003</p>
 * <p>Company: University of Stuttgart</p>
 * @author Illya Stepanov
 * @version 1.1
 */

import de.uni_stuttgart.informatik.canu.mobisim.core.*;
import de.uni_stuttgart.informatik.canu.mobisim.notifications.*;
import de.uni_stuttgart.informatik.canu.spatialmodel.core.*;
import de.uni_stuttgart.informatik.canu.spatialmodel.geometry.*;

/**
 * This class saves the contents of spatial model in Urban Data ASCII (UDA) format. <br>
 * <br>
  * @author Illya Stepanov
 */
public class UDAWriter extends ExtensionModule
{
  /**
   * Output Stream
   */
  protected java.io.PrintStream o = System.err;
  
  /**
   * Spatial Model
   */
  protected SpatialModel spatialModel;

  /**
   * Uniform buildings' height
   */
  protected float uniformHeight = 21.0f;

  /**
   * Constructor
   */
  public UDAWriter()
  {
    super("UDAWriter");
  }

  /**
   * Returns the module's description. <br>
   * <br>
   * @return extension module's description
   */
  public String getDescription()
  {
    return "UDA Writer module";
  }

  /**
   * Executes the extension. <br>
   * <br>
   * The method is called on every simulation timestep.
   * @return 0 - the module should be executed on next timesteps,
   *        -1 - the module should not be executed on further timesteps and should be removed from the extensions' list
   */
  public int act()
  {
    doSave();
    
    return -1;
  }
  
  /**
   * Saves the contents of spatial model in UDA format
   */
  public void doSave()
  {
    // get a list of buildings
    java.util.ArrayList buildings = new java.util.ArrayList();

    // iterate the contents of spatial model
    java.util.Iterator iter = spatialModel.getElements().values().iterator();
    while (iter.hasNext())
    {
      SpatialModelElement element = (SpatialModelElement)iter.next();
      // check if building
      if (element.getClassCode().equals("71") && element.getSubClassCode().equals("10"))
      {
        // store it
        buildings.add(element); 
      }
    }
    
    // save header
    java.util.Date date = new java.util.Date();
    java.text.DateFormat dateFormat = java.text.DateFormat.getInstance();
    
    o.println("Database generated by CanuMobiSim/UDAWriter, contact: Illya Stepanov <illya.stepanov@informatik.uni-stuttgart.de>");
    o.println(dateFormat.format(date));
    o.println("Size of the area:");
    o.println("Max. x = "+(float)u.getDimensionX());
    o.println("Max. y = "+(float)u.getDimensionY());
    o.println(buildings.size()+" "+0+" "+0+" "+(float)u.getDimensionX()+" "+(float)u.getDimensionY());
    
    // iterate the buildings
    iter = buildings.iterator();
    int i=1;  // building's index number
    while (iter.hasNext())
    {
      SpatialModelElement element = (SpatialModelElement)iter.next();
      Polyline shape = (Polyline)element.getGeometry();
      
      // check if the first and the last points are equal
      Point p0 = (Point)shape.getPoints().get(0);
      Point p1 = (Point)shape.getPoints().get(shape.getPoints().size()-1);
      int n = (p0.equals(p1))? shape.getPoints().size()-1 : shape.getPoints().size();
      
      o.print(i+" "+n);
      
      // check if the building's orientation is counter-anticlockwise
      double area2 = 0;
      for (int c=0; c<shape.getPoints().size()-1; c++)
      {
        p0 = (Point)shape.getPoints().get(c);
        p1 = (Point)shape.getPoints().get(c+1);

        area2 += (p0.getX()*p1.getY()-p1.getX()*p0.getY()); 
      }

      if (area2<0)
      {
        // we have the counter-anticlockwise polygon
        
        // output corners
        for (int c=n-1; c>=0; c--)
        {
          Point p = (Point)shape.getPoints().get(c);
          o.print(" "+(float)p.getX()+", "+(float)p.getY());
        }
      }
      else
      {
        // we have the counter-clockwise polygon

        // output corners
        for (int c=0; c<n; c++)
        {
          Point p = (Point)shape.getPoints().get(c);
          o.print(" "+(float)p.getX()+", "+(float)p.getY());
        }
      }

      o.println(" "+uniformHeight+" 4.0 1.0 0.010 20.0 6.0 8.0 15.0 5.0 20 0 \"<NA>\" 0.0 0.0 0.0 0.0");
      i++;
    }
  }
  
  /**
   * Initializes the object from XML tag. <br>
   * <br>
   * @param element source tag
   * @throws Exception Exception if parameters are invalid
   */
  public void load(org.w3c.dom.Element element) throws Exception
  {
    u.sendNotification(new LoaderNotification(this, u, "Loading UDAWriter extension"));

    super.load(element);

    org.w3c.dom.Node n;
    
    String outName = element.getAttribute("output");
    if (outName.length()>0)
      o = new java.io.PrintStream(new java.io.FileOutputStream(outName));    

    n = element.getElementsByTagName("building_height").item(0);
    if(n!=null)
      uniformHeight = Float.parseFloat(n.getFirstChild().getNodeValue());

    spatialModel = (SpatialModel)u.getExtension("SpatialModel");
    if (spatialModel==null)
      throw new Exception("SpatialModel instance does not exist!");
    
    u.sendNotification(new LoaderNotification(this, u, "Finished loading UDAWriter extension"));
  }
}
